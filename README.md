# Bloody Agents

_An agent standard_

**Overview**

This project is meant to be as general as possible, allowing to create any type of agent on any framework or in any paradigm. The point is to unify it in a way such that different agents can interact with each other, even if they are hosted on different servers. As a consequence, this also provides an interface for connecting the environments where agent is hosted and where it is acting (this means that actions can be executed locally for agents running in the cloud).

**L0.** The agent abstraction, in the most general way possible: it takes in some input, streams the intermediate steps, accepts additional feedback. Some tools are executed externally, some internally. The extra tools (or agents ‚Äî they line is blurry) are passed in the agent. Output can have any schema and is validated.

**L1.** Different agent types: here we implement the basic agents and the different high-level approaches. The ReAct agent, feedbacks, and then BabyAGI, AutoGPT, Taskmaster...

**L2.** The agent server. This part includes the protocol for using an agent from another server through a websocket and the communication between servers. Overall, it will be a federative system for sharing agents. 

A useage example: let's say you are building an agent for sales outreach. Then, your clients will be able to use custom subagents for researching/writing, including from other servers. Or you have something which involves characters, and the characters will be able to be imported from anywhere.

<img src="map.png" style="zoom: 33%;" />

### The Agent

An agent has the `run(...) -> Channel` function which takes as arguments the following:

1. The input (which can be of any type, restricted by the `AgentRepr`). This can include the task, the conversation history, etc.
2. The context. This is again restricted only by the `AgentRepr`. It can include, for example, memories, plan, project architecture. The difference with input is that it is passed to the tools or subagents which the agent will use and that it is returned at the end of each action step.
3. Additional minions and tools. If they are not found/supported by the agent, their calls will be returned in the step results through the channel to be made on the client. For instance, for an application performing actions on a local computer while running the agent somewhere else this could be the call to run a command. This will be objects of `ToolRepr`, `AgentRepr`. For an agent executing locally, `Agent` and `Tool` are also accepted.
4. Additional parameters of the agent, as specified in the `AgentRepr`.

The agent returns a `Channel`. The `Channel` is for streaming responses and handling additional input. It has the function `channel.steps(chunks: bool) -> Generator[(Step | StepReader) | ToolResult | MinionStart | MinionResult | FinalResult]`. The `chunks` argument determines whether to stream each step (if not, the steps will be of type `Step`, otherwise `StepReader`). The steps contain calls to tools and minions. Tool calls return `ToolResult`, and for minion calls the channel sends `MinionStart`, then the steps, then `MinionResult`. In the end, the channel yields the `FinalResult`. The channel has a `channel.input(inp: ExtraInput | ToolResult | MinionChannel)` function to give additional input or the results of tool and minion calls.

Internally, the channel has five attributes: the agent, the agent's pool of information (unread steps), the information which wasn't yet yielded by the channel, the tools to handle automatically, and the agent's generator. The generator yields the elements generated by the agent: `(Step | StepReader) | ToolResult | MinionChannel | FinalResult`.

For working with a remote agent, another channel types, inherited from `Channel`, are used:

- `ClientChannel` reads from the websocket inside the generator function and writes to it on `channel.input()`
- `ServerChannel` has the function `.run(socket)` which executes the agent until the end while calling `.input()` by itself on socket input and writing to the socket every time information is received

`AgentRepr` has the following structure:

`input_schema`, `context_schema`: the input and context validation as a JSON Schema

`required_tools`: the list of the string names of required tools and minions

`parameter_schema`: the validations for the `parameters` argument

`ToolRepr` has the `input_schema` and `context_schema`

The `Step` class has these attributes:

- `generated`: str
- `usage`: int - token usage
- `context` - optional, in the case it was changed
- `tool_calls: list[ToolCall]` (`ToolCall = (str, dict[str, Any], dict[str, Any])` - (tool name, input, context))

### Agent implementations

- A basic LLM should be the most basic agent 
- OpenAI Functions agent
- Any LLM agent with ReAct
- Langchain wrapper
- BabyAGI
- Taskmaster

There should be a possibility to define agents from supported types in a yaml file, like [here](https://github.com/ennucore/clippy/blob/master/clippy/minions/specialized_minions.yaml).

### Server protocol

The implementations for `ServerChannel` and `ClientChannel`.

The server can return lists of available tools and agents (`list[AgentRepr]`, `list[ToolRepr]`) and create the websockets for running the agents. 

### Integrations

**ü¶úÔ∏èüîó Langchain** 

Langchain should be an optional dependency. It should be interoperable with this library through this functionality:

- Turning supported LLMs into agents
- Using Langchain agents and tools through wrappers
- Exporting the bloody agents to Langchain

This will allow us to take advantage of Langsmith, Langchain's integrations, token usage tracking, etc.

**Genworlds**

[Genworlds](https://genworlds.com/docs/category/the-genworlds-framework) has another paradigm, and some things are easier to implement in the Genworlds Simulations, while others in the abstractions here (using subagents, for example), but there is a lot of similar concepts. Agents should be controvertible from one form to another (`World`s correspond to the contexts), in particular for the possibility of using the agents from the future Genworlds marketplace.
